////////////////////////////////////////////////////////////////////////////////
// Copyright Â© 2022 xx foundation                                             //
//                                                                            //
// Use of this source code is governed by a license that can be found in the  //
// LICENSE file.                                                              //
////////////////////////////////////////////////////////////////////////////////

//go:build js && wasm

package wasm

import (
	"encoding/base64"
	"github.com/teamortix/golang-wasm/wasm"
	"gitlab.com/elixxir/client/v4/channels"
	channelsDb "gitlab.com/elixxir/xxdk-wasm/src/api/indexedDb/worker/channels"
	"sync"
	"syscall/js"

	"gitlab.com/elixxir/client/v4/bindings"
)

////////////////////////////////////////////////////////////////////////////////
// Basic Channel API                                                          //
////////////////////////////////////////////////////////////////////////////////

// ChannelsManager wraps the [bindings.ChannelsManager] object so its methods
// can be wrapped to be Javascript compatible.
type ChannelsManager struct {
	*bindings.ChannelsManager
}

// identityMap stores identities previously generated by ConstructIdentity.
var identityMap sync.Map

// ConstructIdentity creates a codename in a public [channel.Identity] from an
// extant identity for a given codeset version.
//
// Parameters:
//   - pubKey - The Ed25519 public key.
//   - codesetVersion - The version of the codeset used to generate the
//     identity.
//
// Returns:
//   - JSON of [channel.Identity].
func ConstructIdentity(pubKey []byte, codesetVersion int) ([]byte, error) {
	// Note: This function is similar to constructIdentity below except that it
	//  uses a sync.Map backend to increase efficiency for identities that were
	//  already generated in this browser session.

	pubKeyBase64 := base64.StdEncoding.EncodeToString(pubKey)
	identityObj, exists := identityMap.Load(pubKeyBase64)
	if exists {
		return identityObj.([]byte), nil
	}

	identity, err := bindings.ConstructIdentity(pubKey, codesetVersion)
	if err != nil {
		return nil, err
	}

	identityMap.Store(base64.StdEncoding.EncodeToString(pubKey), identity)

	return identity, nil
}

// NewChannelsManager creates a new [ChannelsManager] from a new private
// identity ([channel.PrivateIdentity]).
//
// This is for creating a manager for an identity for the first time. For
// generating a new one channel identity, use [GenerateChannelIdentity]. To
// reload this channel manager, use [LoadChannelsManager], passing in the
// storage tag retrieved by [ChannelsManager.GetStorageTag].
//
// Parameters:
//   - cmixID - ID of [Cmix] object in tracker. This can be retrieved using
//     [Cmix.GetID].
//   - privateIdentity - Bytes of a private identity ([channel.PrivateIdentity])
//     that is generated by [GenerateChannelIdentity].
//   - eventBuilder - Javascript object that matches the [EventModelBuilder]
//     struct.
func NewChannelsManager(cmixID int, privateIdentity []byte,
	eventBuilder *EventModelBuilder) (*ChannelsManager, error) {
	cm, err := bindings.NewChannelsManager(cmixID, privateIdentity, eventBuilder)
	return &ChannelsManager{cm}, err
}

// LoadChannelsManager loads an existing [ChannelsManager] for the given storage
// tag.
//
// This is for loading a manager for an identity that has already been created.
// The channel manager should have previously been created with
// [NewChannelsManager] and the storage is retrievable with
// [ChannelsManager.GetStorageTag].
//
// Parameters:
//   - cmixID - ID of [Cmix] object in tracker. This can be retrieved using
//     [Cmix.GetID].
//   - privateIdentity - Bytes of a private identity ([channel.PrivateIdentity])
//     that is generated by [GenerateChannelIdentity].
//   - eventBuilder - Javascript object that matches the [EventModelBuilder]
//     struct.
func LoadChannelsManager(cmixID int, storageTag string,
	eventBuilder *EventModelBuilder) (*ChannelsManager, error) {
	cm, err := bindings.LoadChannelsManager(cmixID, storageTag, eventBuilder)
	return &ChannelsManager{cm}, err
}

// NewChannelsManagerWithIndexedDb creates a new [ChannelsManager] from a new
// private identity ([channel.PrivateIdentity]) and using indexedDb as a backend
// to manage the event model.
//
// This is for creating a manager for an identity for the first time. For
// generating a new one channel identity, use [GenerateChannelIdentity]. To
// reload this channel manager, use [LoadChannelsManagerWithIndexedDb], passing
// in the storage tag retrieved by [ChannelsManager.GetStorageTag].
//
// This function initialises an indexedDb database.
//
// Parameters:
//   - cmixID - ID of [Cmix] object in tracker. This can be retrieved using
//     [Cmix.GetID].
//   - wasmJsPath - Path to Javascript file that starts the worker.
//   - privateIdentity - Bytes of a private identity ([channel.PrivateIdentity])
//     that is generated by [bindings.GenerateChannelIdentity].
//   - messageReceivedCB - The received message callback, which is called
//     everytime a message is added or changed in the database. The row in the
//     database that was updated can be found using the UUID. The channel ID is
//     provided so that the recipient can filter if they want to the processes
//     the update now or not. An "update" bool is present that tells you if the
//     row is new or if it is an edited old row.
//   - deletedMessageCB - The deleted message callback, which is called
//     everytime a message is deleted from the database.
//   - mutedUserCB - The muted user callback, which is called everytime a user
//     is muted or unmuted.
//   - cipherID - ID of [ChannelDbCipher] object in tracker. Create this object
//     with [bindings.NewChannelsDatabaseCipher] and get its ID with
//     [ChannelDbCipher.GetID].
func NewChannelsManagerWithIndexedDb(cmixID int, wasmJsPath string,
	privateIdentity []byte, messageReceivedCB channelsDb.MessageReceivedCallback,
	deletedMessageCB channelsDb.DeletedMessageCallback,
	mutedUserCB channelsDb.MutedUserCallback, cipherID int) (*ChannelsManager, error) {

	cipher, err := bindings.GetChannelDbCipherTrackerFromID(cipherID)
	if err != nil {
		return nil, err
	}

	return newChannelsManagerWithIndexedDb(cmixID, wasmJsPath, privateIdentity,
		messageReceivedCB, deletedMessageCB, mutedUserCB, cipher)
}

// NewChannelsManagerWithIndexedDbUnsafe creates a new [ChannelsManager] from a
// new private identity ([channel.PrivateIdentity]) and using indexedDb as a
// backend to manage the event model. However, the data is written in plain text
// and not encrypted. It is recommended that you do not use this in production.
//
// This is for creating a manager for an identity for the first time. For
// generating a new one channel identity, use [GenerateChannelIdentity]. To
// reload this channel manager, use [LoadChannelsManagerWithIndexedDbUnsafe],
// passing in the storage tag retrieved by [ChannelsManager.GetStorageTag].
//
// This function initialises an indexedDb database.
//
// Parameters:
//   - cmixID - ID of [Cmix] object in tracker. This can be retrieved using
//     [Cmix.GetID].
//   - wasmJsPath - Path to Javascript file that starts the worker.
//   - privateIdentity - Bytes of a private identity ([channel.PrivateIdentity])
//     that is generated by [bindings.GenerateChannelIdentity].
//   - messageReceivedCB - The received message callback, which is called
//     everytime a message is added or changed in the database. The row in the
//     database that was updated can be found using the UUID. The channel ID is
//     provided so that the recipient can filter if they want to the processes
//     the update now or not. An "update" bool is present that tells you if the
//     row is new or if it is an edited old row.
//   - deletedMessageCB - The deleted message callback, which is called
//     everytime a message is deleted from the database.
//   - mutedUserCB - The muted user callback, which is called everytime a user
//     is muted or unmuted.
func NewChannelsManagerWithIndexedDbUnsafe(cmixID int, wasmJsPath string,
	privateIdentity []byte,
	messageReceivedCB channelsDb.MessageReceivedCallback,
	deletedMessageCB channelsDb.DeletedMessageCallback,
	mutedUserCB channelsDb.MutedUserCallback) (*ChannelsManager, error) {

	return newChannelsManagerWithIndexedDb(cmixID, wasmJsPath, privateIdentity,
		messageReceivedCB, deletedMessageCB, mutedUserCB, nil)
}

func newChannelsManagerWithIndexedDb(cmixID int, wasmJsPath string,
	privateIdentity []byte, messageReceivedCB channelsDb.MessageReceivedCallback,
	deletedMessageCB channelsDb.DeletedMessageCallback,
	mutedUserCB channelsDb.MutedUserCallback,
	cipher *bindings.ChannelDbCipher) (*ChannelsManager, error) {
	model := channelsDb.NewWASMEventModelBuilder(
		wasmJsPath, cipher, messageReceivedCB, deletedMessageCB, mutedUserCB)

	cm, err :=
		bindings.NewChannelsManagerGoEventModel(cmixID, privateIdentity, model)
	return &ChannelsManager{cm}, err
}

// LoadChannelsManagerWithIndexedDb loads an existing [ChannelsManager] using
// an existing indexedDb database as a backend to manage the event model.
//
// This is for loading a manager for an identity that has already been created.
// The channel manager should have previously been created with
// [NewChannelsManagerWithIndexedDb] and the storage is retrievable with
// [ChannelsManager.GetStorageTag].
//
// Parameters:
//   - cmixID - ID of [Cmix] object in tracker. This can be retrieved using
//     [Cmix.GetID].
//   - wasmJsPath - Path to Javascript file that starts the worker.
//   - storageTag - The storage tag associated with the previously created
//     channel manager and retrieved with [ChannelsManager.GetStorageTag].
//   - messageReceivedCB - The received message callback, which is called
//     everytime a message is added or changed in the database. The row in the
//     database that was updated can be found using the UUID. The channel ID is
//     provided so that the recipient can filter if they want to the processes
//     the update now or not. An "update" bool is present that tells you if the
//     row is new or if it is an edited old row.
//   - deletedMessageCB - The deleted message callback, which is called
//     everytime a message is deleted from the database.
//   - mutedUserCB - The muted user callback, which is called everytime a user
//     is muted or unmuted.
//   - cipherID - ID of [ChannelDbCipher] object in tracker. Create this object
//     with [bindings.NewChannelsDatabaseCipher] and get its ID with
//     [ChannelDbCipher.GetID].
func LoadChannelsManagerWithIndexedDb(cmixID int, wasmJsPath string,
	storageTag string, messageReceivedCB channelsDb.MessageReceivedCallback,
	deletedMessageCB channelsDb.DeletedMessageCallback,
	mutedUserCB channelsDb.MutedUserCallback, cipherID int) (*ChannelsManager, error) {

	cipher, err := bindings.GetChannelDbCipherTrackerFromID(cipherID)
	if err != nil {
		return nil, err
	}

	return loadChannelsManagerWithIndexedDb(cmixID, wasmJsPath, storageTag,
		messageReceivedCB, deletedMessageCB, mutedUserCB, cipher)
}

// LoadChannelsManagerWithIndexedDbUnsafe loads an existing [ChannelsManager]
// using an existing indexedDb database as a backend to manage the event model.
// This should only be used to load unsafe channel managers created by
// [NewChannelsManagerWithIndexedDbUnsafe].
//
// This is for loading a manager for an identity that has already been created.
// The channel manager should have previously been created with
// [NewChannelsManagerWithIndexedDb] and the storage is retrievable with
// [ChannelsManager.GetStorageTag].
//
// Parameters:
//   - cmixID - ID of [Cmix] object in tracker. This can be retrieved using
//     [Cmix.GetID].
//   - wasmJsPath - Path to Javascript file that starts the worker.
//   - storageTag - The storage tag associated with the previously created
//     channel manager and retrieved with [ChannelsManager.GetStorageTag].
//   - messageReceivedCB - The received message callback, which is called
//     everytime a message is added or changed in the database. The row in the
//     database that was updated can be found using the UUID. The channel ID is
//     provided so that the recipient can filter if they want to the processes
//     the update now or not. An "update" bool is present that tells you if the
//     row is new or if it is an edited old row.
//   - deletedMessageCB - The deleted message callback, which is called
//     everytime a message is deleted from the database.
//   - mutedUserCB - The muted user callback, which is called everytime a user
//     is muted or unmuted.
//
// Returns a promise:
//   - Resolves to a Javascript representation of the [ChannelsManager] object.
//   - Rejected with an error if loading indexedDb or the manager fails.
func LoadChannelsManagerWithIndexedDbUnsafe(cmixID int, wasmJsPath string,
	storageTag string, messageReceivedCB channelsDb.MessageReceivedCallback,
	deletedMessageCB channelsDb.DeletedMessageCallback,
	mutedUserCB channelsDb.MutedUserCallback) (*ChannelsManager, error) {

	return loadChannelsManagerWithIndexedDb(cmixID, wasmJsPath, storageTag,
		messageReceivedCB, deletedMessageCB, mutedUserCB, nil)
}

func loadChannelsManagerWithIndexedDb(cmixID int, wasmJsPath, storageTag string,
	messageReceivedCB channelsDb.MessageReceivedCallback,
	deletedMessageCB channelsDb.DeletedMessageCallback,
	mutedUserCB channelsDb.MutedUserCallback,
	cipher *bindings.ChannelDbCipher) (*ChannelsManager, error) {
	model := channelsDb.NewWASMEventModelBuilder(
		wasmJsPath, cipher, messageReceivedCB, deletedMessageCB, mutedUserCB)
	cm, err :=
		bindings.LoadChannelsManagerGoEventModel(cmixID, storageTag, model)
	return &ChannelsManager{cm}, err
}

////////////////////////////////////////////////////////////////////////////////
// Channel Receiving Logic and Callback Registration                          //
////////////////////////////////////////////////////////////////////////////////

// ChannelMessageReceptionCallback wraps a Javascript object so that it
// implements the [bindings.ChannelMessageReceptionCallback] interface.
type ChannelMessageReceptionCallback struct {
	CallbackFn func([]byte, js.Value) int `wasm:"Callback"`
}

// Callback returns the context for a channel message.
//
// Parameters:
//   - receivedChannelMessageReport - Returns the JSON of
//     [bindings.ReceivedChannelMessageReport] (Uint8Array).
//   - err - Returns an error on failure (Error).
//
// Returns:
//   - It must return a unique UUID for the message that it can be referenced by
//     later (int).
func (cmrCB *ChannelMessageReceptionCallback) Callback(
	receivedChannelMessageReport []byte, err error) int {
	return cmrCB.CallbackFn(receivedChannelMessageReport, wasm.NewError(err))
}

// RegisterReceiveHandler is used to register handlers for non-default message
// types. They can be processed by modules. It is important that such modules
// sync up with the event model implementation.
//
// There can only be one handler per [channels.MessageType], and this will
// return an error on any re-registration.
//
// Parameters:
//   - messageType - The [channels.MessageType] that the listener listens for.
//   - listenerCb - Javascript object that matches the
//     [ChannelMessageReceptionCallback] struct. This callback will be executed
//     when a channel message of the messageType is received.
//   - name - A name describing what type of messages the listener picks up.
//     This is used for debugging and logging.
//   - userSpace - Set to true if this listener can receive messages from normal
//     users.
//   - adminSpace - Set to true if this listener can receive messages from
//     admins.
//   - mutedSpace - Set to true if this listener can receive messages from muted
//     users.
func (cm *ChannelsManager) RegisterReceiveHandler(messageType int,
	listenerCb *ChannelMessageReceptionCallback, name string, userSpace,
	adminSpace, mutedSpace bool) error {
	return cm.ChannelsManager.RegisterReceiveHandler(
		messageType, listenerCb, name, userSpace, adminSpace, mutedSpace)
}

////////////////////////////////////////////////////////////////////////////////
// Event Model Logic                                                          //
////////////////////////////////////////////////////////////////////////////////

// EventModelBuilder wraps a Javascript object so that it implements the
// [bindings.EventModelBuilder] interface.
type EventModelBuilder struct {
	BuildFn func(path string) *EventModel `wasm:"Build"`
}

// Build initializes and returns the event model.  It wraps a Javascript object
// that has all the methods in [bindings.EventModel] to make it adhere to the Go
// interface [bindings.EventModel].
func (emb *EventModelBuilder) Build(path string) bindings.EventModel {
	return emb.BuildFn(path)
}

// EventModel wraps a Javascript object so that it implements the
// [bindings.EventModel] interface.
type EventModel struct {
	JoinChannelFn    func(string) `wasm:"JoinChannel"`
	LeaveChannelFn   func([]byte) `wasm:"LeaveChannel"`
	ReceiveMessageFn func([]byte, []byte, string, string, []byte, int32, int,
		int64, int64, int64, int64, int64, bool) int64 `wasm:"ReceiveMessage"`
	ReceiveReplyFn func([]byte, []byte, []byte, string, string, []byte, int32,
		int, int64, int64, int64, int64, int64, bool) int64 `wasm:"ReceiveReply"`
	ReceiveReactionFn func([]byte, []byte, []byte, string, string, []byte,
		int32, int, int64, int64, int64, int64, int64, bool) int64 `wasm:"ReceiveReaction"`
	UpdateFromUUIDFn      func(int64, []byte)          `wasm:"UpdateFromUUID"`
	UpdateFromMessageIDFn func([]byte, []byte) int64   `wasm:"UpdateFromMessageID"`
	GetMessageFn          func([]byte) ([]byte, error) `wasm:"GetMessage"`
	DeleteMessageFn       func([]byte) error           `wasm:"DeleteMessage"`
	MuteUserFn            func([]byte, []byte, bool)   `wasm:"MuteUser"`
}

// JoinChannel is called whenever a channel is joined locally.
//
// Parameters:
//   - channel - Returns the pretty print representation of a channel (string).
func (em *EventModel) JoinChannel(channel string) {
	em.JoinChannelFn(channel)
}

// LeaveChannel is called whenever a channel is left locally.
//
// Parameters:
//   - ChannelId - Marshalled bytes of the channel [id.ID] (Uint8Array).
func (em *EventModel) LeaveChannel(channelID []byte) {
	em.LeaveChannelFn(channelID)
}

// ReceiveMessage is called whenever a message is received on a given channel.
// It may be called multiple times on the same message. It is incumbent on the
// user of the API to filter such called by message ID.
//
// Parameters:
//   - channelID - Marshalled bytes of the channel [id.ID] (Uint8Array).
//   - messageID - The bytes of the [channel.MessageID] of the received message
//     (Uint8Array).
//   - nickname - The nickname of the sender of the message (string).
//   - text - The content of the message (string).
//   - pubKey - The sender's Ed25519 public key (Uint8Array).
//   - dmToken - The dmToken (int32).
//   - codeset - The codeset version (int).
//   - timestamp - Time the message was received; represented as nanoseconds
//     since unix epoch (int).
//   - lease - The number of nanoseconds that the message is valid for (int).
//   - roundId - The ID of the round that the message was received on (int).
//   - msgType - The type of message ([channels.MessageType]) to send (int).
//   - status - The [channels.SentStatus] of the message (int).
//
// Statuses will be enumerated as such:
//
//	Sent      =  0
//	Delivered =  1
//	Failed    =  2
//
// Returns:
//   - A non-negative unique UUID for the message that it can be referenced by
//     later with [eventModel.UpdateSentStatus].
func (em *EventModel) ReceiveMessage(channelID, messageID []byte, nickname,
	text string, pubKey []byte, dmToken int32, codeset int, timestamp, lease,
	roundId, msgType, status int64, hidden bool) int64 {
	return em.ReceiveMessage(channelID, messageID, nickname, text, pubKey,
		dmToken, codeset, timestamp, lease, roundId, msgType, status, hidden)
}

// ReceiveReply is called whenever a message is received that is a reply on a
// given channel. It may be called multiple times on the same message. It is
// incumbent on the user of the API to filter such called by message ID.
//
// Messages may arrive our of order, so a reply in theory can arrive before the
// initial message. As a result, it may be important to buffer replies.
//
// Parameters:
//   - channelID - Marshalled bytes of the channel [id.ID] (Uint8Array).
//   - messageID - The bytes of the [channel.MessageID] of the received message
//     (Uint8Array).
//   - reactionTo - The [channel.MessageID] for the message that received a
//     reply (Uint8Array).
//   - senderUsername - The username of the sender of the message (string).
//   - text - The content of the message (string).
//   - pubKey - The sender's Ed25519 public key (Uint8Array).
//   - dmToken - The dmToken (int32).
//   - codeset - The codeset version (int).
//   - timestamp - Time the message was received; represented as nanoseconds
//     since unix epoch (int).
//   - lease - The number of nanoseconds that the message is valid for (int).
//   - roundId - The ID of the round that the message was received on (int).
//   - msgType - The type of message ([channels.MessageType]) to send (int).
//   - status - The [channels.SentStatus] of the message (int).
//
// Statuses will be enumerated as such:
//
//	Sent      =  0
//	Delivered =  1
//	Failed    =  2
//
// Returns:
//   - A non-negative unique UUID for the message that it can be referenced by
//     later with [eventModel.UpdateSentStatus].
func (em *EventModel) ReceiveReply(channelID, messageID, reactionTo []byte,
	senderUsername, text string, pubKey []byte, dmToken int32, codeset int, timestamp, lease,
	roundId, msgType, status int64, hidden bool) int64 {
	return em.ReceiveReplyFn(channelID, messageID, reactionTo, senderUsername,
		text, pubKey, dmToken, codeset, timestamp, lease, roundId, msgType,
		status, hidden)
}

// ReceiveReaction is called whenever a reaction to a message is received on a
// given channel. It may be called multiple times on the same reaction. It is
// incumbent on the user of the API to filter such called by message ID.
//
// Messages may arrive our of order, so a reply in theory can arrive before the
// initial message. As a result, it may be important to buffer reactions.
//
// Parameters:
//   - channelID - Marshalled bytes of the channel [id.ID] (Uint8Array).
//   - messageID - The bytes of the [channel.MessageID] of the received message
//     (Uint8Array).
//   - reactionTo - The [channel.MessageID] for the message that received a
//     reply (Uint8Array).
//   - senderUsername - The username of the sender of the message (string).
//   - reaction - The contents of the reaction message (string).
//   - pubKey - The sender's Ed25519 public key (Uint8Array).
//   - dmToken - The dmToken (int32).
//   - codeset - The codeset version (int).
//   - timestamp - Time the message was received; represented as nanoseconds
//     since unix epoch (int).
//   - lease - The number of nanoseconds that the message is valid for (int).
//   - roundId - The ID of the round that the message was received on (int).
//   - msgType - The type of message ([channels.MessageType]) to send (int).
//   - status - The [channels.SentStatus] of the message (int).
//
// Statuses will be enumerated as such:
//
//	Sent      =  0
//	Delivered =  1
//	Failed    =  2
//
// Returns:
//   - A non-negative unique UUID for the message that it can be referenced by
//     later with [eventModel.UpdateSentStatus].
func (em *EventModel) ReceiveReaction(channelID, messageID, reactionTo []byte,
	senderUsername, reaction string, pubKey []byte, dmToken int32, codeset int,
	timestamp, lease, roundId, msgType, status int64, hidden bool) int64 {
	return em.ReceiveReactionFn(channelID, messageID, reactionTo, senderUsername,
		reaction, pubKey, dmToken, codeset, timestamp, lease, roundId, msgType,
		status, hidden)
}

// UpdateFromUUID is called whenever a message at the UUID is modified.
//
// Parameters:
//   - uuid - The unique identifier of the message in the database (int).
//   - messageUpdateInfoJSON - JSON of [bindings.MessageUpdateInfo]
//     (Uint8Array).
func (em *EventModel) UpdateFromUUID(uuid int64, messageUpdateInfoJSON []byte) {
	em.UpdateFromUUIDFn(uuid, messageUpdateInfoJSON)
}

// UpdateFromMessageID is called whenever a message with the message ID is
// modified.
//
// Parameters:
//   - messageID - The bytes of the [channel.MessageID] of the received message
//     (Uint8Array).
//   - messageUpdateInfoJSON - JSON of [bindings.MessageUpdateInfo
//     (Uint8Array).
//
// Returns:
//   - A non-negative unique uuid for the modified message by which it can be
//     referenced later with [EventModel.UpdateFromUUID] int).
func (em *EventModel) UpdateFromMessageID(
	messageID []byte, messageUpdateInfoJSON []byte) int64 {
	return em.UpdateFromMessageIDFn(messageID, messageUpdateInfoJSON)
}

// GetMessage returns the message with the given [channel.MessageID].
//
// Note for developers: The internal Javascript function must return JSON of
// MessageAndError, which includes the returned [channels.ModelMessage] or any
// error that occurs during lookup.
//
// Parameters:
//   - messageID - The bytes of the [channel.MessageID] of the message
//     (Uint8Array).
//
// Returns:
//   - JSON of [channels.ModelMessage] (Uint8Array).
func (em *EventModel) GetMessage(messageID []byte) ([]byte, error) {
	return em.GetMessageFn(messageID)
}

// DeleteMessage deletes the message with the given [channel.MessageID] from
// the database.
//
// Parameters:
//   - messageID - The bytes of the [channel.MessageID] of the message.
func (em *EventModel) DeleteMessage(messageID []byte) error {
	return em.DeleteMessageFn(messageID)
}

// MuteUser mutes the given user or unmutes them.
//
// Parameters:
//   - channelID - The bytes of the [id.ID] of the channel the user is being
//     muted in.
//   - pubKey - The [ed25519.PublicKey] of the user that is muted or unmuted.
func (em *EventModel) MuteUser(channelID, pubkey []byte, unmute bool) {
	em.MuteUserFn(channelID, pubkey, unmute)
}

// MessageAndError contains a message returned by eventModel.GetMessage or any
// possible error that occurs during lookup. Only one field should be present at
// a time; if an error occurs, ModelMessage should be empty.
//
// Example JSON:
//
//	{
//	  "ModelMessage": {
//	    "UUID": 50,
//	    "Nickname": "Nickname",
//	    "MessageID": "ODg5goFIBvpvqPzuoYGqmvxFYBgj0MMiQxAB51Q2nPs=",
//	    "ChannelID": "R+xKJTH6m4YRS4f0JggK3fTu10sANmtahS0Qtc8yi/AD",
//	    "ParentMessageID": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
//	    "Timestamp": "1955-11-05T12:01:00-07:00",
//	    "Lease": 21600000000000,
//	    "Status": 2,
//	    "Hidden": false,
//	    "Pinned": false,
//	    "Content": "VGhpcyBpcyBzb21lIG1lc3NhZ2UgY29udGVudC4=",
//	    "Type": 1,
//	    "Round": 7,
//	    "PubKey": "QyTtpndOf3sDZehVpOBQzQNBe1R2Eae7qlAEDZJ2mLg=",
//	    "CodesetVersion": 0
//	  },
//	  "Error": ""
//	}
type MessageAndError struct {
	// MessageJSON should contain the JSON of channels.ModelMessage.
	ModelMessage channels.ModelMessage

	// Error should only be filled when an error occurs on message lookup.
	Error string
}
